import * as _xmtp_node_bindings from '@xmtp/node-bindings';
import { Message, Conversation as Conversation$1, PermissionUpdateType, PermissionPolicy, MetadataField, ListMessagesOptions, ConsentState, Conversations as Conversations$1, CreateGroupOptions, ListConversationsOptions, LogLevel, Client as Client$1, Consent, ConsentEntityType } from '@xmtp/node-bindings';
export { Consent, ConsentEntityType, ConsentState, ContentTypeId, ConversationType, CreateGroupOptions, DeliveryStatus, EncodedContent, GroupMember, GroupMembershipState, GroupMessageKind, GroupMetadata, GroupPermissions, GroupPermissionsOptions, HmacKey, InboxState, Installation, ListConversationsOptions, ListMessagesOptions, LogLevel, LogOptions, Message, MetadataField, PermissionLevel, PermissionPolicy, PermissionPolicySet, PermissionUpdateType, SignatureRequestType, SortDirection } from '@xmtp/node-bindings';
import { ContentTypeId, ContentCodec, EncodedContent } from '@xmtp/content-type-primitives';

type ResolveValue<T> = {
    value: T | undefined;
    done: boolean;
};
type StreamCallback<T> = (err: Error | null, value: T | undefined) => void;
declare class AsyncStream<T> {
    #private;
    onReturn: (() => void) | undefined;
    constructor();
    get isDone(): boolean;
    callback: StreamCallback<T>;
    next: () => Promise<ResolveValue<T>>;
    return: (value: T | undefined) => Promise<{
        done: boolean;
        value: T | undefined;
    }>;
    [Symbol.asyncIterator](): this;
}

type MessageKind = "application" | "membership_change";
type MessageDeliveryStatus = "unpublished" | "published" | "failed";
declare class DecodedMessage<T = any> {
    #private;
    content: T;
    contentType: ContentTypeId | undefined;
    conversationId: string;
    deliveryStatus: MessageDeliveryStatus;
    fallback?: string;
    compression?: number;
    id: string;
    kind: MessageKind;
    parameters: Record<string, string>;
    senderInboxId: string;
    sentAt: Date;
    sentAtNs: number;
    constructor(client: Client, message: Message);
}

declare class Conversation {
    #private;
    constructor(client: Client, group: Conversation$1);
    get id(): string;
    get name(): string;
    updateName(name: string): Promise<void>;
    get imageUrl(): string;
    updateImageUrl(imageUrl: string): Promise<void>;
    get description(): string;
    updateDescription(description: string): Promise<void>;
    get pinnedFrameUrl(): string;
    updatePinnedFrameUrl(pinnedFrameUrl: string): Promise<void>;
    get isActive(): boolean;
    get addedByInboxId(): string;
    get createdAtNs(): number;
    get createdAt(): Date;
    metadata(): Promise<{
        creatorInboxId: string;
        conversationType: string;
    }>;
    members(): Promise<_xmtp_node_bindings.GroupMember[]>;
    get admins(): string[];
    get superAdmins(): string[];
    get permissions(): {
        policyType: _xmtp_node_bindings.GroupPermissionsOptions;
        policySet: _xmtp_node_bindings.PermissionPolicySet;
    };
    updatePermission(permissionType: PermissionUpdateType, policy: PermissionPolicy, metadataField?: MetadataField): Promise<void>;
    isAdmin(inboxId: string): boolean;
    isSuperAdmin(inboxId: string): boolean;
    sync(): Promise<void>;
    stream(callback?: StreamCallback<DecodedMessage>): AsyncStream<DecodedMessage<any>>;
    addMembers(accountAddresses: string[]): Promise<void>;
    addMembersByInboxId(inboxIds: string[]): Promise<void>;
    removeMembers(accountAddresses: string[]): Promise<void>;
    removeMembersByInboxId(inboxIds: string[]): Promise<void>;
    addAdmin(inboxId: string): Promise<void>;
    removeAdmin(inboxId: string): Promise<void>;
    addSuperAdmin(inboxId: string): Promise<void>;
    removeSuperAdmin(inboxId: string): Promise<void>;
    publishMessages(): Promise<void>;
    sendOptimistic(content: any, contentType?: ContentTypeId): string;
    send(content: any, contentType?: ContentTypeId): Promise<string>;
    messages(options?: ListMessagesOptions): Promise<DecodedMessage[]>;
    get consentState(): ConsentState;
    updateConsentState(consentState: ConsentState): void;
    get dmPeerInboxId(): string;
}

declare class Conversations {
    #private;
    constructor(client: Client, conversations: Conversations$1);
    getConversationById(id: string): Conversation | null;
    getDmByInboxId(inboxId: string): Conversation | null;
    getMessageById<T = any>(id: string): DecodedMessage<T> | null;
    newGroup(accountAddresses: string[], options?: CreateGroupOptions): Promise<Conversation>;
    newDm(accountAddress: string): Promise<Conversation>;
    list(options?: ListConversationsOptions): Conversation[];
    listGroups(options?: Omit<ListConversationsOptions, "conversationType">): Conversation[];
    listDms(options?: Omit<ListConversationsOptions, "conversationType">): Conversation[];
    sync(): Promise<void>;
    syncAll(): Promise<bigint>;
    stream(callback?: StreamCallback<Conversation>): AsyncStream<Conversation>;
    streamGroups(callback?: StreamCallback<Conversation>): AsyncStream<Conversation>;
    streamDms(callback?: StreamCallback<Conversation>): AsyncStream<Conversation>;
    streamAllMessages(callback?: StreamCallback<DecodedMessage>): Promise<AsyncStream<DecodedMessage<any>>>;
    streamAllGroupMessages(callback?: StreamCallback<DecodedMessage>): Promise<AsyncStream<DecodedMessage<any>>>;
    streamAllDmMessages(callback?: StreamCallback<DecodedMessage>): Promise<AsyncStream<DecodedMessage<any>>>;
    hmacKeys(): Record<string, _xmtp_node_bindings.HmacKey[]>;
}

type SignMessage = (message: string) => Promise<Uint8Array> | Uint8Array;
type GetAddress = () => Promise<string> | string;
type GetChainId = () => bigint;
type GetBlockNumber = () => bigint;
type Signer = {
    getAddress: GetAddress;
    signMessage: SignMessage;
    getBlockNumber?: GetBlockNumber;
    getChainId?: GetChainId;
};
type SmartContractSigner = Required<Signer>;
declare const isSmartContractSigner: (signer: Signer) => signer is SmartContractSigner;

declare const ApiUrls: {
    readonly local: "http://localhost:5556";
    readonly dev: "https://grpc.dev.xmtp.network:443";
    readonly production: "https://grpc.production.xmtp.network:443";
};
declare const HistorySyncUrls: {
    readonly local: "http://localhost:5558";
    readonly dev: "https://message-history.dev.ephemera.network";
    readonly production: "https://message-history.production.ephemera.network";
};
type XmtpEnv = keyof typeof ApiUrls;
/**
 * Network options
 */
type NetworkOptions = {
    /**
     * Specify which XMTP environment to connect to. (default: `dev`)
     */
    env?: XmtpEnv;
    /**
     * apiUrl can be used to override the `env` flag and connect to a
     * specific endpoint
     */
    apiUrl?: string;
    /**
     * historySyncUrl can be used to override the `env` flag and connect to a
     * specific endpoint for syncing history
     */
    historySyncUrl?: string;
};
/**
 * Storage options
 */
type StorageOptions = {
    /**
     * Path to the local DB
     */
    dbPath?: string;
};
type ContentOptions = {
    /**
     * Allow configuring codecs for additional content types
     */
    codecs?: ContentCodec[];
};
type OtherOptions = {
    /**
     * Enable structured JSON logging
     */
    structuredLogging?: boolean;
    /**
     * Logging level
     */
    loggingLevel?: LogLevel;
    /**
     * Disable automatic registration when creating a client
     */
    disableAutoRegister?: boolean;
};
type ClientOptions = NetworkOptions & StorageOptions & ContentOptions & OtherOptions;
declare class Client {
    #private;
    constructor(client: Client$1, signer: Signer, codecs: ContentCodec[]);
    static create(signer: Signer, encryptionKey: Uint8Array, options?: ClientOptions): Promise<Client>;
    get accountAddress(): string;
    get inboxId(): string;
    get installationId(): string;
    get installationIdBytes(): Uint8Array<ArrayBufferLike>;
    get isRegistered(): boolean;
    register(): Promise<void>;
    addAccount(newAccountSigner: Signer): Promise<void>;
    removeAccount(accountAddress: string): Promise<void>;
    revokeAllOtherInstallations(): Promise<void>;
    revokeInstallations(installationIds: Uint8Array[]): Promise<void>;
    canMessage(accountAddresses: string[]): Promise<Map<string, boolean>>;
    static canMessage(accountAddresses: string[], env?: XmtpEnv): Promise<Map<string, boolean>>;
    get conversations(): Conversations;
    codecFor(contentType: ContentTypeId): ContentCodec | undefined;
    encodeContent(content: any, contentType: ContentTypeId): EncodedContent<Record<string, string>>;
    decodeContent(message: Message, contentType: ContentTypeId): any;
    requestHistorySync(): Promise<void>;
    getInboxIdByAddress(accountAddress: string): Promise<string | null>;
    inboxState(refreshFromNetwork?: boolean): Promise<_xmtp_node_bindings.InboxState>;
    getLatestInboxState(inboxId: string): Promise<_xmtp_node_bindings.InboxState>;
    inboxStateFromInboxIds(inboxIds: string[], refreshFromNetwork?: boolean): Promise<_xmtp_node_bindings.InboxState[]>;
    setConsentStates(consentStates: Consent[]): Promise<void>;
    getConsentState(entityType: ConsentEntityType, entity: string): Promise<_xmtp_node_bindings.ConsentState>;
    signWithInstallationKey(signatureText: string): Uint8Array<ArrayBufferLike>;
    verifySignedWithInstallationKey(signatureText: string, signatureBytes: Uint8Array): boolean;
    static verifySignedWithPublicKey(signatureText: string, signatureBytes: Uint8Array, publicKey: Uint8Array): boolean;
    static isAddressAuthorized(inboxId: string, address: string, options?: NetworkOptions): Promise<boolean>;
    static isInstallationAuthorized(inboxId: string, installation: Uint8Array, options?: NetworkOptions): Promise<boolean>;
}

declare const generateInboxId: (accountAddress: string) => string;
declare const getInboxIdForAddress: (accountAddress: string, env?: XmtpEnv) => Promise<string | null>;

export { ApiUrls, Client, type ClientOptions, Conversation, Conversations, DecodedMessage, HistorySyncUrls, type NetworkOptions, type OtherOptions, type Signer, type SmartContractSigner, type StorageOptions, type StreamCallback, type XmtpEnv, generateInboxId, getInboxIdForAddress, isSmartContractSigner };
