import { join } from 'node:path';
import process from 'node:process';
import { GroupUpdatedCodec, ContentTypeGroupUpdated } from '@xmtp/content-type-group-updated';
import { ContentTypeText, TextCodec } from '@xmtp/content-type-text';
import { getInboxIdForAddress as getInboxIdForAddress$1, generateInboxId as generateInboxId$1, createClient, verifySignedWithPublicKey, isAddressAuthorized, isInstallationAuthorized } from '@xmtp/node-bindings';
export { GroupMember, GroupMetadata, GroupPermissions } from '@xmtp/node-bindings';
import { ContentTypeId } from '@xmtp/content-type-primitives';

class AsyncStream {
    #done = false;
    #resolveNext;
    #queue;
    onReturn = undefined;
    constructor() {
        this.#queue = [];
        this.#resolveNext = null;
        this.#done = false;
    }
    get isDone() {
        return this.#done;
    }
    callback = (error, value) => {
        if (error) {
            throw error;
        }
        if (this.#done) {
            return;
        }
        if (this.#resolveNext) {
            this.#resolveNext({
                done: false,
                value,
            });
            this.#resolveNext = null;
        }
        else {
            this.#queue.push(value);
        }
    };
    next = () => {
        if (this.#queue.length > 0) {
            return Promise.resolve({
                done: false,
                value: this.#queue.shift(),
            });
        }
        else if (this.#done) {
            return Promise.resolve({
                done: true,
                value: undefined,
            });
        }
        else {
            return new Promise((resolve) => {
                this.#resolveNext = resolve;
            });
        }
    };
    return = (value) => {
        this.#done = true;
        this.onReturn?.();
        return Promise.resolve({
            done: true,
            value,
        });
    };
    [Symbol.asyncIterator]() {
        return this;
    }
}

function nsToDate(ns) {
    return new Date(ns / 1_000_000);
}

class DecodedMessage {
    #client;
    content;
    contentType;
    conversationId;
    deliveryStatus;
    fallback;
    compression;
    id;
    kind;
    parameters;
    senderInboxId;
    sentAt;
    sentAtNs;
    constructor(client, message) {
        this.#client = client;
        this.id = message.id;
        this.sentAtNs = message.sentAtNs;
        this.sentAt = nsToDate(message.sentAtNs);
        this.conversationId = message.convoId;
        this.senderInboxId = message.senderInboxId;
        switch (message.kind) {
            case 0 /* GroupMessageKind.Application */:
                this.kind = "application";
                break;
            case 1 /* GroupMessageKind.MembershipChange */:
                this.kind = "membership_change";
                break;
            // no default
        }
        switch (message.deliveryStatus) {
            case 0 /* DeliveryStatus.Unpublished */:
                this.deliveryStatus = "unpublished";
                break;
            case 1 /* DeliveryStatus.Published */:
                this.deliveryStatus = "published";
                break;
            case 2 /* DeliveryStatus.Failed */:
                this.deliveryStatus = "failed";
                break;
            // no default
        }
        this.contentType = message.content.type
            ? new ContentTypeId(message.content.type)
            : undefined;
        this.parameters = message.content.parameters;
        this.fallback = message.content.fallback;
        this.compression = message.content.compression;
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
        this.content = this.contentType
            ? this.#client.decodeContent(message, this.contentType)
            : undefined;
    }
}

class Conversation {
    #client;
    #group;
    constructor(client, group) {
        this.#client = client;
        this.#group = group;
    }
    get id() {
        return this.#group.id();
    }
    get name() {
        return this.#group.groupName();
    }
    async updateName(name) {
        return this.#group.updateGroupName(name);
    }
    get imageUrl() {
        return this.#group.groupImageUrlSquare();
    }
    async updateImageUrl(imageUrl) {
        return this.#group.updateGroupImageUrlSquare(imageUrl);
    }
    get description() {
        return this.#group.groupDescription();
    }
    async updateDescription(description) {
        return this.#group.updateGroupDescription(description);
    }
    get pinnedFrameUrl() {
        return this.#group.groupPinnedFrameUrl();
    }
    async updatePinnedFrameUrl(pinnedFrameUrl) {
        return this.#group.updateGroupPinnedFrameUrl(pinnedFrameUrl);
    }
    get isActive() {
        return this.#group.isActive();
    }
    get addedByInboxId() {
        return this.#group.addedByInboxId();
    }
    get createdAtNs() {
        return this.#group.createdAtNs();
    }
    get createdAt() {
        return nsToDate(this.createdAtNs);
    }
    async metadata() {
        const metadata = await this.#group.groupMetadata();
        return {
            creatorInboxId: metadata.creatorInboxId(),
            conversationType: metadata.conversationType(),
        };
    }
    async members() {
        return this.#group.listMembers();
    }
    get admins() {
        return this.#group.adminList();
    }
    get superAdmins() {
        return this.#group.superAdminList();
    }
    get permissions() {
        const permissions = this.#group.groupPermissions();
        return {
            policyType: permissions.policyType(),
            policySet: permissions.policySet(),
        };
    }
    async updatePermission(permissionType, policy, metadataField) {
        return this.#group.updatePermissionPolicy(permissionType, policy, metadataField);
    }
    isAdmin(inboxId) {
        return this.#group.isAdmin(inboxId);
    }
    isSuperAdmin(inboxId) {
        return this.#group.isSuperAdmin(inboxId);
    }
    async sync() {
        return this.#group.sync();
    }
    stream(callback) {
        const asyncStream = new AsyncStream();
        const stream = this.#group.stream((error, value) => {
            const message = value
                ? new DecodedMessage(this.#client, value)
                : undefined;
            asyncStream.callback(error, message);
            callback?.(error, message);
        });
        asyncStream.onReturn = stream.end.bind(stream);
        return asyncStream;
    }
    async addMembers(accountAddresses) {
        return this.#group.addMembers(accountAddresses);
    }
    async addMembersByInboxId(inboxIds) {
        return this.#group.addMembersByInboxId(inboxIds);
    }
    async removeMembers(accountAddresses) {
        return this.#group.removeMembers(accountAddresses);
    }
    async removeMembersByInboxId(inboxIds) {
        return this.#group.removeMembersByInboxId(inboxIds);
    }
    async addAdmin(inboxId) {
        return this.#group.addAdmin(inboxId);
    }
    async removeAdmin(inboxId) {
        return this.#group.removeAdmin(inboxId);
    }
    async addSuperAdmin(inboxId) {
        return this.#group.addSuperAdmin(inboxId);
    }
    async removeSuperAdmin(inboxId) {
        return this.#group.removeSuperAdmin(inboxId);
    }
    async publishMessages() {
        return this.#group.publishMessages();
    }
    sendOptimistic(content, contentType) {
        if (typeof content !== "string" && !contentType) {
            throw new Error("Content type is required when sending content other than text");
        }
        const encodedContent = typeof content === "string"
            ? this.#client.encodeContent(content, contentType ?? ContentTypeText)
            : // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                this.#client.encodeContent(content, contentType);
        return this.#group.sendOptimistic(encodedContent);
    }
    async send(content, contentType) {
        if (typeof content !== "string" && !contentType) {
            throw new Error("Content type is required when sending content other than text");
        }
        const encodedContent = typeof content === "string"
            ? this.#client.encodeContent(content, contentType ?? ContentTypeText)
            : // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                this.#client.encodeContent(content, contentType);
        return this.#group.send(encodedContent);
    }
    async messages(options) {
        const messages = await this.#group.findMessages(options);
        return (messages
            .map((message) => new DecodedMessage(this.#client, message))
            // filter out messages without content
            .filter((message) => message.content !== undefined));
    }
    get consentState() {
        return this.#group.consentState();
    }
    updateConsentState(consentState) {
        this.#group.updateConsentState(consentState);
    }
    get dmPeerInboxId() {
        return this.#group.dmPeerInboxId();
    }
}

class Conversations {
    #client;
    #conversations;
    constructor(client, conversations) {
        this.#client = client;
        this.#conversations = conversations;
    }
    getConversationById(id) {
        try {
            // findGroupById will throw if group is not found
            const group = this.#conversations.findGroupById(id);
            return new Conversation(this.#client, group);
        }
        catch {
            return null;
        }
    }
    getDmByInboxId(inboxId) {
        try {
            // findDmByTargetInboxId will throw if group is not found
            const group = this.#conversations.findDmByTargetInboxId(inboxId);
            return new Conversation(this.#client, group);
        }
        catch {
            return null;
        }
    }
    getMessageById(id) {
        try {
            // findMessageById will throw if message is not found
            const message = this.#conversations.findMessageById(id);
            return new DecodedMessage(this.#client, message);
        }
        catch {
            return null;
        }
    }
    async newGroup(accountAddresses, options) {
        const group = await this.#conversations.createGroup(accountAddresses, options);
        const conversation = new Conversation(this.#client, group);
        return conversation;
    }
    async newDm(accountAddress) {
        const group = await this.#conversations.createDm(accountAddress);
        const conversation = new Conversation(this.#client, group);
        return conversation;
    }
    list(options) {
        const groups = this.#conversations.list(options);
        return groups.map((group) => {
            const conversation = new Conversation(this.#client, group);
            return conversation;
        });
    }
    listGroups(options) {
        const groups = this.#conversations.listGroups(options);
        return groups.map((group) => {
            const conversation = new Conversation(this.#client, group);
            return conversation;
        });
    }
    listDms(options) {
        const groups = this.#conversations.listDms(options);
        return groups.map((group) => {
            const conversation = new Conversation(this.#client, group);
            return conversation;
        });
    }
    async sync() {
        return this.#conversations.sync();
    }
    async syncAll() {
        return this.#conversations.syncAllConversations();
    }
    stream(callback) {
        const asyncStream = new AsyncStream();
        const stream = this.#conversations.stream((err, value) => {
            const conversation = value
                ? new Conversation(this.#client, value)
                : undefined;
            asyncStream.callback(err, conversation);
            callback?.(err, conversation);
        });
        asyncStream.onReturn = stream.end.bind(stream);
        return asyncStream;
    }
    streamGroups(callback) {
        const asyncStream = new AsyncStream();
        const stream = this.#conversations.streamGroups((err, value) => {
            const conversation = value
                ? new Conversation(this.#client, value)
                : undefined;
            asyncStream.callback(err, conversation);
            callback?.(err, conversation);
        });
        asyncStream.onReturn = stream.end.bind(stream);
        return asyncStream;
    }
    streamDms(callback) {
        const asyncStream = new AsyncStream();
        const stream = this.#conversations.streamDms((err, value) => {
            const conversation = value
                ? new Conversation(this.#client, value)
                : undefined;
            asyncStream.callback(err, conversation);
            callback?.(err, conversation);
        });
        asyncStream.onReturn = stream.end.bind(stream);
        return asyncStream;
    }
    async streamAllMessages(callback) {
        // sync conversations first
        await this.sync();
        const asyncStream = new AsyncStream();
        const stream = this.#conversations.streamAllMessages((err, value) => {
            const decodedMessage = value
                ? new DecodedMessage(this.#client, value)
                : undefined;
            asyncStream.callback(err, decodedMessage);
            callback?.(err, decodedMessage);
        });
        asyncStream.onReturn = stream.end.bind(stream);
        return asyncStream;
    }
    async streamAllGroupMessages(callback) {
        // sync conversations first
        await this.sync();
        const asyncStream = new AsyncStream();
        const stream = this.#conversations.streamAllGroupMessages((err, value) => {
            const decodedMessage = value
                ? new DecodedMessage(this.#client, value)
                : undefined;
            asyncStream.callback(err, decodedMessage);
            callback?.(err, decodedMessage);
        });
        asyncStream.onReturn = stream.end.bind(stream);
        return asyncStream;
    }
    async streamAllDmMessages(callback) {
        // sync conversations first
        await this.sync();
        const asyncStream = new AsyncStream();
        const stream = this.#conversations.streamAllDmMessages((err, value) => {
            const decodedMessage = value
                ? new DecodedMessage(this.#client, value)
                : undefined;
            asyncStream.callback(err, decodedMessage);
            callback?.(err, decodedMessage);
        });
        asyncStream.onReturn = stream.end.bind(stream);
        return asyncStream;
    }
    hmacKeys() {
        return this.#conversations.getHmacKeys();
    }
}

const isSmartContractSigner = (signer) => "getBlockNumber" in signer && "getChainId" in signer;

const ApiUrls = {
    local: "http://localhost:5556",
    dev: "https://grpc.dev.xmtp.network:443",
    production: "https://grpc.production.xmtp.network:443",
};
const HistorySyncUrls = {
    local: "http://localhost:5558",
    dev: "https://message-history.dev.ephemera.network",
    production: "https://message-history.production.ephemera.network",
};
class Client {
    #innerClient;
    #conversations;
    #signer;
    #codecs;
    constructor(client, signer, codecs) {
        this.#innerClient = client;
        this.#conversations = new Conversations(this, client.conversations());
        this.#signer = signer;
        this.#codecs = new Map(codecs.map((codec) => [codec.contentType.toString(), codec]));
    }
    static async create(signer, encryptionKey, options) {
        const accountAddress = await signer.getAddress();
        const host = options?.apiUrl || ApiUrls[options?.env || "dev"];
        const isSecure = host.startsWith("https");
        const dbPath = options?.dbPath ||
            join(process.cwd(), `xmtp-${options?.env || "dev"}-${accountAddress}.db3`);
        const inboxId = (await getInboxIdForAddress$1(host, isSecure, accountAddress)) ||
            generateInboxId$1(accountAddress);
        const logOptions = {
            structured: options?.structuredLogging ?? false,
            level: options?.loggingLevel ?? "off" /* LogLevel.off */,
        };
        const historySyncUrl = options?.historySyncUrl || HistorySyncUrls[options?.env || "dev"];
        const client = new Client(await createClient(host, isSecure, dbPath, inboxId, accountAddress, encryptionKey, historySyncUrl, logOptions), signer, [new GroupUpdatedCodec(), new TextCodec(), ...(options?.codecs ?? [])]);
        if (!options?.disableAutoRegister) {
            await client.register();
        }
        return client;
    }
    get accountAddress() {
        return this.#innerClient.accountAddress;
    }
    get inboxId() {
        return this.#innerClient.inboxId();
    }
    get installationId() {
        return this.#innerClient.installationId();
    }
    get installationIdBytes() {
        return this.#innerClient.installationIdBytes();
    }
    get isRegistered() {
        return this.#innerClient.isRegistered();
    }
    async #createInboxSignatureText() {
        try {
            const signatureText = await this.#innerClient.createInboxSignatureText();
            return signatureText;
        }
        catch {
            return null;
        }
    }
    async #addAccountSignatureText(newAccountAddress) {
        try {
            const signatureText = await this.#innerClient.addWalletSignatureText(newAccountAddress);
            return signatureText;
        }
        catch {
            return null;
        }
    }
    async #removeAccountSignatureText(accountAddress) {
        try {
            const signatureText = await this.#innerClient.revokeWalletSignatureText(accountAddress);
            return signatureText;
        }
        catch {
            return null;
        }
    }
    async #revokeAllOtherInstallationsSignatureText() {
        try {
            const signatureText = await this.#innerClient.revokeAllOtherInstallationsSignatureText();
            return signatureText;
        }
        catch {
            return null;
        }
    }
    async #revokeInstallationsSignatureText(installationIds) {
        try {
            const signatureText = await this.#innerClient.revokeInstallationsSignatureText(installationIds);
            return signatureText;
        }
        catch {
            return null;
        }
    }
    async #addSignature(signatureType, signatureText, signer) {
        const signature = await signer.signMessage(signatureText);
        if (isSmartContractSigner(signer)) {
            await this.#innerClient.addScwSignature(signatureType, signature, signer.getChainId(), signer.getBlockNumber());
        }
        else {
            await this.#innerClient.addSignature(signatureType, signature);
        }
    }
    async #applySignatures() {
        return this.#innerClient.applySignatureRequests();
    }
    async register() {
        const signatureText = await this.#createInboxSignatureText();
        // if the signature text is not available, the client is already registered
        if (!signatureText) {
            return;
        }
        await this.#addSignature(1 /* SignatureRequestType.CreateInbox */, signatureText, this.#signer);
        return this.#innerClient.registerIdentity();
    }
    async addAccount(newAccountSigner) {
        const signatureText = await this.#addAccountSignatureText(await newAccountSigner.getAddress());
        if (!signatureText) {
            throw new Error("Unable to generate add account signature text");
        }
        await this.#addSignature(0 /* SignatureRequestType.AddWallet */, signatureText, newAccountSigner);
        await this.#applySignatures();
    }
    async removeAccount(accountAddress) {
        const signatureText = await this.#removeAccountSignatureText(accountAddress);
        if (!signatureText) {
            throw new Error("Unable to generate remove account signature text");
        }
        await this.#addSignature(2 /* SignatureRequestType.RevokeWallet */, signatureText, this.#signer);
        await this.#applySignatures();
    }
    async revokeAllOtherInstallations() {
        const signatureText = await this.#revokeAllOtherInstallationsSignatureText();
        if (!signatureText) {
            throw new Error("Unable to generate revoke all other installations signature text");
        }
        await this.#addSignature(3 /* SignatureRequestType.RevokeInstallations */, signatureText, this.#signer);
        await this.#applySignatures();
    }
    async revokeInstallations(installationIds) {
        const signatureText = await this.#revokeInstallationsSignatureText(installationIds);
        if (!signatureText) {
            throw new Error("Unable to generate revoke installations signature text");
        }
        await this.#addSignature(3 /* SignatureRequestType.RevokeInstallations */, signatureText, this.#signer);
        await this.#applySignatures();
    }
    async canMessage(accountAddresses) {
        const canMessage = await this.#innerClient.canMessage(accountAddresses);
        return new Map(Object.entries(canMessage));
    }
    static async canMessage(accountAddresses, env) {
        const accountAddress = "0x0000000000000000000000000000000000000000";
        const host = ApiUrls[env || "dev"];
        const isSecure = host.startsWith("https");
        const inboxId = (await getInboxIdForAddress$1(host, isSecure, accountAddress)) ||
            generateInboxId$1(accountAddress);
        const signer = {
            getAddress: () => accountAddress,
            signMessage: () => new Uint8Array(),
        };
        const client = new Client(await createClient(host, isSecure, undefined, inboxId, accountAddress), signer, []);
        return client.canMessage(accountAddresses);
    }
    get conversations() {
        return this.#conversations;
    }
    codecFor(contentType) {
        return this.#codecs.get(contentType.toString());
    }
    encodeContent(content, contentType) {
        const codec = this.codecFor(contentType);
        if (!codec) {
            throw new Error(`no codec for ${contentType.toString()}`);
        }
        const encoded = codec.encode(content, this);
        const fallback = codec.fallback(content);
        if (fallback) {
            encoded.fallback = fallback;
        }
        return encoded;
    }
    decodeContent(message, contentType) {
        const codec = this.codecFor(contentType);
        if (!codec) {
            throw new Error(`no codec for ${contentType.toString()}`);
        }
        // throw an error if there's an invalid group membership change message
        if (contentType.sameAs(ContentTypeGroupUpdated) &&
            message.kind !== 1 /* GroupMessageKind.MembershipChange */) {
            throw new Error("Error decoding group membership change");
        }
        // eslint-disable-next-line @typescript-eslint/no-unsafe-return
        return codec.decode(message.content, this);
    }
    async requestHistorySync() {
        return this.#innerClient.sendHistorySyncRequest();
    }
    async getInboxIdByAddress(accountAddress) {
        return this.#innerClient.findInboxIdByAddress(accountAddress);
    }
    async inboxState(refreshFromNetwork = false) {
        return this.#innerClient.inboxState(refreshFromNetwork);
    }
    async getLatestInboxState(inboxId) {
        return this.#innerClient.getLatestInboxState(inboxId);
    }
    async inboxStateFromInboxIds(inboxIds, refreshFromNetwork) {
        return this.#innerClient.addressesFromInboxId(refreshFromNetwork ?? false, inboxIds);
    }
    async setConsentStates(consentStates) {
        return this.#innerClient.setConsentStates(consentStates);
    }
    async getConsentState(entityType, entity) {
        return this.#innerClient.getConsentState(entityType, entity);
    }
    signWithInstallationKey(signatureText) {
        return this.#innerClient.signWithInstallationKey(signatureText);
    }
    verifySignedWithInstallationKey(signatureText, signatureBytes) {
        try {
            this.#innerClient.verifySignedWithInstallationKey(signatureText, signatureBytes);
            return true;
        }
        catch {
            return false;
        }
    }
    static verifySignedWithPublicKey(signatureText, signatureBytes, publicKey) {
        try {
            verifySignedWithPublicKey(signatureText, signatureBytes, publicKey);
            return true;
        }
        catch {
            return false;
        }
    }
    static async isAddressAuthorized(inboxId, address, options) {
        const host = options?.apiUrl || ApiUrls[options?.env || "dev"];
        return await isAddressAuthorized(host, inboxId, address);
    }
    static async isInstallationAuthorized(inboxId, installation, options) {
        const host = options?.apiUrl || ApiUrls[options?.env || "dev"];
        return await isInstallationAuthorized(host, inboxId, installation);
    }
}

const generateInboxId = (accountAddress) => {
    return generateInboxId$1(accountAddress);
};
const getInboxIdForAddress = async (accountAddress, env = "dev") => {
    const host = ApiUrls[env];
    const isSecure = host.startsWith("https");
    return getInboxIdForAddress$1(host, isSecure, accountAddress);
};

export { ApiUrls, Client, Conversation, Conversations, DecodedMessage, HistorySyncUrls, generateInboxId, getInboxIdForAddress, isSmartContractSigner };
//# sourceMappingURL=index.js.map
