/* auto-generated by NAPI-RS */
/* eslint-disable */
export declare class Client {
  accountAddress: string
  inboxId(): string
  isRegistered(): boolean
  installationId(): string
  installationIdBytes(): Uint8Array
  canMessage(accountAddresses: Array<string>): Promise<Record<string, boolean>>
  registerIdentity(): Promise<void>
  conversations(): Conversations
  sendHistorySyncRequest(): Promise<void>
  sendConsentSyncRequest(): Promise<void>
  findInboxIdByAddress(address: string): Promise<string | null>
  addressesFromInboxId(refreshFromNetwork: boolean, inboxIds: Array<string>): Promise<Array<InboxState>>
  setConsentStates(records: Array<Consent>): Promise<void>
  getConsentState(entityType: ConsentEntityType, entity: string): Promise<ConsentState>
  /**
   * Get the client's inbox state.
   *
   * If `refresh_from_network` is true, the client will go to the network first to refresh the state.
   * Otherwise, the state will be read from the local database.
   */
  inboxState(refreshFromNetwork: boolean): Promise<InboxState>
  getLatestInboxState(inboxId: string): Promise<InboxState>
  createInboxSignatureText(): Promise<string | null>
  addWalletSignatureText(newWalletAddress: string): Promise<string>
  revokeWalletSignatureText(walletAddress: string): Promise<string>
  revokeAllOtherInstallationsSignatureText(): Promise<string>
  revokeInstallationsSignatureText(installationIds: Array<Uint8Array>): Promise<string>
  addSignature(signatureType: SignatureRequestType, signatureBytes: Uint8Array): Promise<void>
  addScwSignature(signatureType: SignatureRequestType, signatureBytes: Uint8Array, chainId: bigint, blockNumber?: bigint | undefined | null): Promise<void>
  applySignatureRequests(): Promise<void>
  signWithInstallationKey(signatureText: string): Uint8Array
  verifySignedWithInstallationKey(signatureText: string, signatureBytes: Uint8Array): void
}

export declare class Conversation {
  id(): string
  send(encodedContent: EncodedContent): Promise<string>
  sendOptimistic(encodedContent: EncodedContent): string
  publishMessages(): Promise<void>
  sync(): Promise<void>
  findMessages(opts?: ListMessagesOptions | undefined | null): Promise<Array<Message>>
  processStreamedGroupMessage(envelopeBytes: Uint8Array): Promise<Message>
  listMembers(): Promise<Array<GroupMember>>
  adminList(): Array<string>
  superAdminList(): Array<string>
  isAdmin(inboxId: string): boolean
  isSuperAdmin(inboxId: string): boolean
  addMembers(accountAddresses: Array<string>): Promise<void>
  addAdmin(inboxId: string): Promise<void>
  removeAdmin(inboxId: string): Promise<void>
  addSuperAdmin(inboxId: string): Promise<void>
  removeSuperAdmin(inboxId: string): Promise<void>
  groupPermissions(): GroupPermissions
  addMembersByInboxId(inboxIds: Array<string>): Promise<void>
  removeMembers(accountAddresses: Array<string>): Promise<void>
  removeMembersByInboxId(inboxIds: Array<string>): Promise<void>
  updateGroupName(groupName: string): Promise<void>
  groupName(): string
  updateGroupImageUrlSquare(groupImageUrlSquare: string): Promise<void>
  groupImageUrlSquare(): string
  updateGroupDescription(groupDescription: string): Promise<void>
  groupDescription(): string
  updateGroupPinnedFrameUrl(pinnedFrameUrl: string): Promise<void>
  groupPinnedFrameUrl(): string
  stream(callback: (err: null | Error, result: Message | undefined) => void): StreamCloser
  createdAtNs(): number
  isActive(): boolean
  addedByInboxId(): string
  groupMetadata(): Promise<GroupMetadata>
  consentState(): ConsentState
  updateConsentState(state: ConsentState): void
  dmPeerInboxId(): string
  updatePermissionPolicy(permissionUpdateType: PermissionUpdateType, permissionPolicyOption: PermissionPolicy, metadataField?: MetadataField | undefined | null): Promise<void>
}

export declare class Conversations {
  createGroup(accountAddresses: Array<string>, options?: CreateGroupOptions | undefined | null): Promise<Conversation>
  createDm(accountAddress: string): Promise<Conversation>
  findGroupById(groupId: string): Conversation
  findDmByTargetInboxId(targetInboxId: string): Conversation
  findMessageById(messageId: string): Message
  processStreamedWelcomeMessage(envelopeBytes: Uint8Array): Promise<Conversation>
  sync(): Promise<void>
  syncAllConversations(): Promise<bigint>
  list(opts?: ListConversationsOptions | undefined | null): Array<Conversation>
  listGroups(opts?: ListConversationsOptions | undefined | null): Array<Conversation>
  listDms(opts?: ListConversationsOptions | undefined | null): Array<Conversation>
  getHmacKeys(): Record<string, Array<HmacKey>>
  stream(callback: (err: null | Error, result: Conversation | undefined) => void): StreamCloser
  streamGroups(callback: (err: null | Error, result: Conversation | undefined) => void): StreamCloser
  streamDms(callback: (err: null | Error, result: Conversation | undefined) => void): StreamCloser
  streamAllMessages(callback: (err: null | Error, result: Message | undefined) => void): StreamCloser
  streamAllGroupMessages(callback: (err: null | Error, result: Message | undefined) => void): StreamCloser
  streamAllDmMessages(callback: (err: null | Error, result: Message | undefined) => void): StreamCloser
}

export declare class GroupMember {
  inboxId: string
  accountAddresses: Array<string>
  installationIds: Array<string>
  permissionLevel: PermissionLevel
  consentState: ConsentState
}

export declare class GroupMetadata {
  creatorInboxId(): string
  conversationType(): string
}

export declare class GroupPermissions {
  policyType(): GroupPermissionsOptions
  policySet(): PermissionPolicySet
}

export declare class StreamCloser {
  /**
   * Signal the stream to end
   * Does not wait for the stream to end.
   */
  end(): void
  /**
   * End the stream and `await` for it to shutdown
   * Returns the `Result` of the task.
   * End the stream and asynchronously wait for it to shutdown
   */
  endAndWait(): Promise<void>
  waitForReady(): Promise<void>
  /** Checks if this stream is closed */
  isClosed(): boolean
}

export interface Consent {
  entityType: ConsentEntityType
  state: ConsentState
  entity: string
}

export declare const enum ConsentEntityType {
  GroupId = 0,
  InboxId = 1,
  Address = 2
}

export declare const enum ConsentState {
  Unknown = 0,
  Allowed = 1,
  Denied = 2
}

export interface ContentTypeId {
  authorityId: string
  typeId: string
  versionMajor: number
  versionMinor: number
}

export declare const enum ConversationType {
  Dm = 0,
  Group = 1,
  Sync = 2
}

/**
 * Create a client
 *
 * Optionally specify a filter for the log level as a string.
 * It can be one of: `debug`, `info`, `warn`, `error` or 'off'.
 * By default, logging is disabled.
 */
export declare export declare function createClient(host: string, isSecure: boolean, dbPath: string | undefined | null, inboxId: string, accountAddress: string, encryptionKey?: Uint8Array | undefined | null, historySyncUrl?: string | undefined | null, logOptions?: LogOptions | undefined | null): Promise<Client>

export interface CreateGroupOptions {
  permissions?: GroupPermissionsOptions
  groupName?: string
  groupImageUrlSquare?: string
  groupDescription?: string
  groupPinnedFrameUrl?: string
  customPermissionPolicySet?: PermissionPolicySet
  messageExpirationFromMs?: number
  messageExpirationMs?: number
}

export declare const enum DeliveryStatus {
  Unpublished = 0,
  Published = 1,
  Failed = 2
}

export interface EncodedContent {
  type?: ContentTypeId
  parameters: Record<string, string>
  fallback?: string
  compression?: number
  content: Uint8Array
}

export declare export declare function generateInboxId(accountAddress: string): string

export declare export declare function getInboxIdForAddress(host: string, isSecure: boolean, accountAddress: string): Promise<string | null>

export declare const enum GroupMembershipState {
  Allowed = 0,
  Rejected = 1,
  Pending = 2
}

export declare const enum GroupMessageKind {
  Application = 0,
  MembershipChange = 1
}

export declare const enum GroupPermissionsOptions {
  Default = 0,
  AdminOnly = 1,
  CustomPolicy = 2
}

export interface HmacKey {
  key: Array<number>
  epoch: bigint
}

export interface InboxState {
  inboxId: string
  recoveryAddress: string
  installations: Array<Installation>
  accountAddresses: Array<string>
}

export interface Installation {
  bytes: Uint8Array
  clientTimestampNs?: bigint
  id: string
}

export declare export declare function isAddressAuthorized(host: string, inboxId: string, address: string): Promise<boolean>

export declare export declare function isInstallationAuthorized(host: string, inboxId: string, installationId: Uint8Array): Promise<boolean>

export interface ListConversationsOptions {
  allowedStates?: Array<GroupMembershipState>
  createdAfterNs?: number
  createdBeforeNs?: number
  limit?: number
  conversationType?: ConversationType
}

export interface ListMessagesOptions {
  sentBeforeNs?: number
  sentAfterNs?: number
  limit?: number
  deliveryStatus?: DeliveryStatus
  direction?: SortDirection
}

export declare const enum LogLevel {
  off = 'off',
  error = 'error',
  warn = 'warn',
  info = 'info',
  debug = 'debug',
  trace = 'trace'
}

/** Specify options for the logger */
export interface LogOptions {
  /**
   * enable structured JSON logging to stdout.Useful for third-party log viewers
   * an option so that it does not require being specified in js object.
   */
  structured?: boolean
  /** Filter logs by level */
  level?: LogLevel
}

export interface Message {
  id: string
  sentAtNs: number
  convoId: string
  senderInboxId: string
  content: EncodedContent
  kind: GroupMessageKind
  deliveryStatus: DeliveryStatus
}

export declare const enum MetadataField {
  GroupName = 0,
  Description = 1,
  ImageUrlSquare = 2,
  PinnedFrameUrl = 3
}

export declare const enum PermissionLevel {
  Member = 0,
  Admin = 1,
  SuperAdmin = 2
}

export declare const enum PermissionPolicy {
  Allow = 0,
  Deny = 1,
  Admin = 2,
  SuperAdmin = 3,
  DoesNotExist = 4,
  Other = 5
}

export interface PermissionPolicySet {
  addMemberPolicy: PermissionPolicy
  removeMemberPolicy: PermissionPolicy
  addAdminPolicy: PermissionPolicy
  removeAdminPolicy: PermissionPolicy
  updateGroupNamePolicy: PermissionPolicy
  updateGroupDescriptionPolicy: PermissionPolicy
  updateGroupImageUrlSquarePolicy: PermissionPolicy
  updateGroupPinnedFrameUrlPolicy: PermissionPolicy
  updateMessageExpirationMsPolicy: PermissionPolicy
}

export declare const enum PermissionUpdateType {
  AddMember = 0,
  RemoveMember = 1,
  AddAdmin = 2,
  RemoveAdmin = 3,
  UpdateMetadata = 4
}

export declare const enum SignatureRequestType {
  AddWallet = 0,
  CreateInbox = 1,
  RevokeWallet = 2,
  RevokeInstallations = 3
}

export declare const enum SortDirection {
  Ascending = 0,
  Descending = 1
}

export declare export declare function verifySignedWithPublicKey(signatureText: string, signatureBytes: Uint8Array, publicKey: Uint8Array): void
