{"version":3,"sources":["../src/client.ts","../src/helper.ts","../src/index.ts"],"sourcesContent":["import {\n  DecodedMessage,\n  Client as XmtpClient,\n  type XmtpEnv,\n  type Conversation,\n} from \"@xmtp/node-sdk\";\nimport { createSigner, getEncryptionKeyFromHex } from \"./helper.ts\";\n\nimport {\n  composeContext,\n  Content,\n  elizaLogger,\n  Memory,\n  ModelClass,\n  stringToUuid,\n  messageCompletionFooter,\n  generateMessageResponse,\n  Client,\n  IAgentRuntime,\n} from \"@elizaos/core\";\n\nlet client: XmtpClient = null;\nlet elizaRuntime: IAgentRuntime = null;\n\nexport const messageHandlerTemplate =\n  // {{goals}}\n  `# Action Examples\n{{actionExamples}}\n(Action examples are for reference only. Do not use the information from them in your response.)\n\n# Knowledge\n{{knowledge}}\n\n# Task: Generate dialog and actions for the character {{agentName}}.\nAbout {{agentName}}:\n{{bio}}\n{{lore}}\n\n{{providers}}\n\n{{attachments}}\n\n# Capabilities\nNote that {{agentName}} is capable of reading/seeing/hearing various forms of media, including images, videos, audio, plaintext and PDFs. Recent attachments have been included above under the \"Attachments\" section.\n\n{{messageDirections}}\n\n{{recentMessages}}\n\n{{actions}}\n\n# Instructions: Write the next message for {{agentName}}.\n` + messageCompletionFooter;\n\nexport const XmtpClientInterface: Client = {\n  start: async (runtime: IAgentRuntime) => {\n    if (!client) {\n      elizaRuntime = runtime;\n\n      const signer = createSigner(process.env.WALLET_KEY as `0x${string}`);\n      const encryptionKey = getEncryptionKeyFromHex(\n        process.env.ENCRYPTION_KEY as string\n      );\n      const env: XmtpEnv = \"production\";\n\n      elizaLogger.success(`Creating client on the '${env}' network...`);\n      client = await XmtpClient.create(signer, encryptionKey, {\n        env,\n      });\n\n      elizaLogger.success(\"Syncing conversations...\");\n      await client.conversations.sync();\n\n      elizaLogger.success(\n        `Agent initialized on ${client.accountAddress}\\nSend a message on http://xmtp.chat/dm/${client.accountAddress}?env=${env}`\n      );\n\n      elizaLogger.success(\"Waiting for messages...\");\n      const stream = client.conversations.streamAllMessages();\n\n      elizaLogger.success(\"âœ… XMTP client started\");\n\n      for await (const message of await stream) {\n        if (\n          message?.senderInboxId.toLowerCase() ===\n            client.inboxId.toLowerCase() ||\n          message?.contentType?.typeId !== \"text\"\n        ) {\n          continue;\n        }\n\n        // Ignore own messages\n        if (message.senderInboxId === client.inboxId) {\n          continue;\n        }\n\n        elizaLogger.success(\n          `Received message: ${message.content as string} by ${\n            message.senderInboxId\n          }`\n        );\n\n        const conversation = client.conversations.getConversationById(\n          message.conversationId\n        );\n\n        if (!conversation) {\n          console.log(\"Unable to find conversation, skipping\");\n          continue;\n        }\n\n        elizaLogger.success(`Sending \"gm\" response...`);\n\n        await processMessage(message, conversation);\n\n        elizaLogger.success(\"Waiting for messages...\");\n      }\n\n      return client;\n    }\n  },\n  stop: async (_runtime: IAgentRuntime) => {\n    elizaLogger.warn(\"XMTP client does not support stopping yet\");\n  },\n};\n\nconst processMessage = async (\n  message: DecodedMessage,\n  conversation: Conversation\n) => {\n  try {\n    const text = message?.content?.text ?? \"\";\n    const messageId = stringToUuid(message.id as string);\n    const userId = stringToUuid(message.senderInboxId as string);\n    const roomId = stringToUuid(message.conversationId as string);\n    await elizaRuntime.ensureConnection(\n      userId,\n      roomId,\n      message.senderInboxId,\n      message.senderInboxId,\n      \"xmtp\"\n    );\n\n    const content: Content = {\n      text,\n      source: \"xmtp\",\n      inReplyTo: undefined,\n    };\n\n    const userMessage = {\n      content,\n      userId,\n      roomId,\n      agentId: elizaRuntime.agentId,\n    };\n\n    const memory: Memory = {\n      id: messageId,\n      agentId: elizaRuntime.agentId,\n      userId,\n      roomId,\n      content,\n      createdAt: Date.now(),\n    };\n\n    await elizaRuntime.messageManager.createMemory(memory);\n\n    const state = await elizaRuntime.composeState(userMessage, {\n      agentName: elizaRuntime.character.name,\n    });\n\n    const context = composeContext({\n      state,\n      template: messageHandlerTemplate,\n    });\n\n    const response = await generateMessageResponse({\n      runtime: elizaRuntime,\n      context,\n      modelClass: ModelClass.LARGE,\n    });\n    const _newMessage = [\n      {\n        text: response?.text,\n        source: \"xmtp\",\n        inReplyTo: messageId,\n      },\n    ];\n    // save response to memory\n    const responseMessage = {\n      ...userMessage,\n      userId: elizaRuntime.agentId,\n      content: response,\n    };\n\n    await elizaRuntime.messageManager.createMemory(responseMessage);\n\n    if (!response) {\n      elizaLogger.error(\"No response from generateMessageResponse\");\n      return;\n    }\n\n    await elizaRuntime.evaluate(memory, state);\n\n    const _result = await elizaRuntime.processActions(\n      memory,\n      [responseMessage],\n      state,\n      async (newMessages) => {\n        if (newMessages.text) {\n          _newMessage.push({\n            text: newMessages.text,\n            source: \"xmtp\",\n            inReplyTo: undefined,\n          });\n        }\n        return [memory];\n      }\n    );\n    for (const newMsg of _newMessage) {\n      await conversation?.send(newMsg.text);\n    }\n  } catch (error) {\n    elizaLogger.error(\"Error in onMessage\", error);\n  }\n};\n\nexport default XmtpClientInterface;\n","import { getRandomValues } from \"node:crypto\";\nimport { fromString, toString } from \"uint8arrays\";\nimport { toBytes } from \"viem\";\nimport { privateKeyToAccount } from \"viem/accounts\";\n\nexport const createSigner = (privateKey: `0x${string}`) => {\n    const account = privateKeyToAccount(privateKey);\n    return {\n        getAddress: () => account.address,\n        signMessage: async (message: string) => {\n            const signature = await account.signMessage({\n                message,\n            });\n            return toBytes(signature);\n        },\n    };\n};\n\nexport const generateEncryptionKeyHex = () => {\n    const uint8Array = getRandomValues(new Uint8Array(32));\n    return toString(uint8Array, \"hex\");\n};\n\nexport const getEncryptionKeyFromHex = (hex: string) => {\n    return fromString(hex, \"hex\");\n};\n","import { XmtpClientInterface } from \"./client\";\n\nconst xmtpPlugin = {\n    name: \"xmtp\",\n    description: \"XMTP client\",\n    clients: [XmtpClientInterface],\n};\nexport default xmtpPlugin;\n"],"mappings":"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","names":[]}