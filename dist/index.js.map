{"version":3,"sources":["../src/index.ts"],"sourcesContent":["import { Message, XMTP, xmtpClient } from \"@xmtp/agent-starter\";\nimport {\n    composeContext,\n    Content,\n    elizaLogger,\n    Memory,\n    ModelClass,\n    stringToUuid,\n    messageCompletionFooter,\n    generateMessageResponse,\n    Client,\n    IAgentRuntime,\n} from \"@elizaos/core\";\n\nlet xmtp: XMTP = null;\nlet elizaRuntime: IAgentRuntime = null;\n\nexport const messageHandlerTemplate =\n    // {{goals}}\n    `# Action Examples\n{{actionExamples}}\n(Action examples are for reference only. Do not use the information from them in your response.)\n\n# Knowledge\n{{knowledge}}\n\n# Task: Generate dialog and actions for the character {{agentName}}.\nAbout {{agentName}}:\n{{bio}}\n{{lore}}\n\n{{providers}}\n\n{{attachments}}\n\n# Capabilities\nNote that {{agentName}} is capable of reading/seeing/hearing various forms of media, including images, videos, audio, plaintext and PDFs. Recent attachments have been included above under the \"Attachments\" section.\n\n{{messageDirections}}\n\n{{recentMessages}}\n\n{{actions}}\n\n# Instructions: Write the next message for {{agentName}}.\n` + messageCompletionFooter;\n\nexport const XmtpClientInterface: Client = {\n    name: 'xmtp',\n    start: async (runtime: IAgentRuntime) => {\n        if (!xmtp) {\n            elizaRuntime = runtime;\n\n            xmtp = await xmtpClient({\n                walletKey: process.env.EVM_PRIVATE_KEY as string,\n                onMessage,\n            });\n\n            elizaLogger.success(\"âœ… XMTP client started\");\n            elizaLogger.info(`XMTP address: ${xmtp.address}`);\n            elizaLogger.info(`Talk to me on:`);\n            elizaLogger.log(\n                `Converse: https://converse.xyz/dm/${xmtp.address}`\n            );\n            elizaLogger.log(\n                `Coinbase Wallet: https://go.cb-w.com/messaging?address=${xmtp.address}`\n            );\n            elizaLogger.log(\n                `Web or Farcaster Frame: https://client.message-kit.org/?address=${xmtp.address}`\n            );\n\n            return xmtp;\n        }\n        return xmtp;\n    },\n    stop: async (_runtime: IAgentRuntime) => {\n        elizaLogger.warn(\"XMTP client does not support stopping yet\");\n    },\n};\n\nconst onMessage = async (message: Message) => {\n    elizaLogger.info(\n        `Decoded message: ${message.content?.text ?? \"no text\"} by ${\n            message.sender.address\n        }`\n    );\n\n    try {\n        const text = message?.content?.text ?? \"\";\n        const messageId = stringToUuid(message.id as string);\n        const userId = stringToUuid(message.sender.address as string);\n        const roomId = stringToUuid(message.group.id as string);\n        await elizaRuntime.ensureConnection(\n            userId,\n            roomId,\n            message.sender.address,\n            message.sender.address,\n            \"xmtp\"\n        );\n\n        const content: Content = {\n            text,\n            source: \"xmtp\",\n            inReplyTo: undefined,\n        };\n\n        const userMessage = {\n            content,\n            userId,\n            roomId,\n            agentId: elizaRuntime.agentId,\n        };\n\n        const memory: Memory = {\n            id: messageId,\n            agentId: elizaRuntime.agentId,\n            userId,\n            roomId,\n            content,\n            createdAt: Date.now(),\n        };\n\n        await elizaRuntime.messageManager.createMemory(memory);\n\n        const state = await elizaRuntime.composeState(userMessage, {\n            agentName: elizaRuntime.character.name,\n        });\n\n        const context = composeContext({\n            state,\n            template: messageHandlerTemplate,\n        });\n\n        const response = await generateMessageResponse({\n            runtime: elizaRuntime,\n            context,\n            modelClass: ModelClass.LARGE,\n        });\n        const _newMessage = [\n            {\n                text: response?.text,\n                source: \"xmtp\",\n                inReplyTo: messageId,\n            },\n        ];\n        // save response to memory\n        const responseMessage = {\n            ...userMessage,\n            userId: elizaRuntime.agentId,\n            content: response,\n        };\n\n        await elizaRuntime.messageManager.createMemory(responseMessage);\n\n        if (!response) {\n            elizaLogger.error(\"No response from generateMessageResponse\");\n            return;\n        }\n\n        await elizaRuntime.evaluate(memory, state);\n\n        const _result = await elizaRuntime.processActions(\n            memory,\n            [responseMessage],\n            state,\n            async (newMessages) => {\n                if (newMessages.text) {\n                    _newMessage.push({\n                        text: newMessages.text,\n                        source: \"xmtp\",\n                        inReplyTo: undefined,\n                    });\n                }\n                return [memory];\n            }\n        );\n        for (const newMsg of _newMessage) {\n            await xmtp.send({\n                message: newMsg.text,\n                originalMessage: message,\n                metadata: {},\n            });\n        }\n    } catch (error) {\n        elizaLogger.error(\"Error in onMessage\", error);\n    }\n};\n\nexport default XmtpClientInterface;\n"],"mappings":"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","names":[]}